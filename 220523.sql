--CROSS JOIN - ORACLE METHOD
SELECT ROWNUM AS RNUM
     , NVL(A.DEPT_CD, '(NULL)') AS A_DEPT_CD
     , NVL(A.DEPT_NM, '(NULL)') AS A_DEPT_NM
     , NVL(B.EMP_NO, '(NULL)') AS B_EMP_NO
     , NVL(B.EMP_NM, '(NULL)') AS B_EMP_NM
     , NVL(B.DEPT_CD, '(NULL)') AS B_DEPT_CD
FROM TB_DEPT_6_1_10 A
   , TB_EMP_6_1_10 B
ORDER BY RNUM
;

--CROSS JOIN - ANSI METHOD
SELECT ROWNUM AS RNUM
     , NVL(A.DEPT_CD, '(NULL)') AS A_DEPT_CD
     , NVL(A.DEPT_NM, '(NULL)') AS A_DEPT_NM
     , NVL(B.EMP_NO, '(NULL)') AS B_EMP_NO
     , NVL(B.EMP_NM, '(NULL)') AS B_EMP_NM
     , NVL(B.DEPT_CD, '(NULL)') AS B_DEPT_CD
FROM TB_DEPT_6_1_10 A CROSS JOIN TB_EMP_6_1_10 B
ORDER BY RNUM
;

--복제용 임시 테이블 생성
CREATE TABLE TB_COPY_3
(
  COPY_NUM NUMBER
, CONSTRAINT PK_TB_COPY_3 PRIMARY KEY (COPY_NUM)
)
;

INSERT INTO TB_COPY_3 (COPY_NUM) VALUES (1);
INSERT INTO TB_COPY_3 (COPY_NUM) VALUES (2);
INSERT INTO TB_COPY_3 (COPY_NUM) VALUES (3);

SELECT * FROM TB_COPY_3;

--6-18 CROSS JOIN을 이용한 데이터 복제
SELECT A.INDUTY_CL_SE_CD
     , A.INDUTY_CL_SE_NM
     , B.COPY_NUM AS 집합번호
FROM TB_INDUTY_CL_SE A CROSS JOIN TB_COPY_3 B
ORDER BY B.COPY_NUM, A.INDUTY_CL_SE_CD
;

--6-19 UNION 연산 
SELECT A.INDUTY_CL_CD AS 업종분류코드
  FROM TB_INDUTY_CL A
 WHERE A.INDUTY_CL_SE_CD = 'ICS001' --대
   AND A.INDUTY_CL_CD = 'Q' --음식
UNION
SELECT A.UPPER_INDUTY_CL_CD AS 상위업종분류코드
  FROM TB_INDUTY_CL A
 WHERE INDUTY_CL_SE_CD = 'ICS002' --중
   AND A.INDUTY_CL_CD LIKE 'Q%' --커피점/카페
;
--6-20 UNION ALL 연산 
SELECT A.INDUTY_CL_CD AS 업종분류코드
  FROM TB_INDUTY_CL A
 WHERE A.INDUTY_CL_SE_CD = 'ICS001' --대
   AND A.INDUTY_CL_CD = 'Q' --음식
UNION ALL
SELECT A.UPPER_INDUTY_CL_CD AS 상위업종분류코드
  FROM TB_INDUTY_CL A
 WHERE INDUTY_CL_SE_CD = 'ICS002' --중
   AND A.INDUTY_CL_CD LIKE 'Q%' --커피점/카페
;

--6-21 UNION ALL 연산 및 ORDER BY 절의 사용
SELECT A.INDUTY_CL_CD, A.INDUTY_CL_NM --필드 수가 다음 SELECT문의 것과 맞아야 함
FROM TB_INDUTY_CL A
WHERE INDUTY_CL_SE_CD = 'ICS002' --중
AND A.INDUTY_CL_CD LIKE 'N%' --관광/여가/오락
UNION ALL
SELECT B.INDUTY_CL_CD AS 업종분류코드, B.INDUTY_CL_NM AS 업종분류명
FROM TB_INDUTY_CL B
WHERE B.INDUTY_CL_SE_CD = 'ICS002' --중
  AND B.INDUTY_CL_CD LIKE '0%' --숙박
ORDER BY INDUTY_CL_CD
;

--6-22 INTERSECT 연산
SELECT A.SUBWAY_STATN_NO
     , A.LN_NM
     , A.STATN_NM
FROM TB_SUBWAY_STATN A
WHERE A.STATN_NM = '신도림'
INTERSECT
SELECT B.SUBWAY_STATN_NO
     , B.LN_NM
     , B.STATN_NM
FROM TB_SUBWAY_STATN B
WHERE B.LN_NM = '2호선'
ORDER BY SUBWAY_STATN_NO
;
--INTERSECT 연산과 동일한 결과집합 도출
SELECT A.SUBWAY_STATN_NO
     , A.LN_NM
     , A.STATN_NM
FROM TB_SUBWAY_STATN A
WHERE A.STATN_NM = '신도림'
  AND EXISTS (SELECT 1
                FROM TB_SUBWAY_STATN K
               WHERE K.SUBWAY_STATN_NO = A.SUBWAY_STATN_NO
                 AND K.LN_NM = '2호선')
ORDER BY SUBWAY_STATN_NO
;

SELECT 1, SUBWAY_STATN_NO, LN_NM, STATN_NM
FROM TB_SUBWAY_STATN K
WHERE K.LN_NM = '2호선';

--6-25 MINUS 연산
SELECT A.LN_NM
  FROM TB_SUBWAY_STATN A
 WHERE A.STATN_NM = '선릉'
 MINUS
SELECT B.LN_NM
  FROM TB_SUBWAY_STATN B
 WHERE B.STATN_NM = '강남'
;

SELECT * FROM DUAL;

--MINUS 연산의 결과집합은 중복이 제거됨
SELECT '선릉' AS 역명 FROM DUAL
UNION ALL
SELECT '선릉' AS 역명 FROM DUAL
;

SELECT '선릉' AS 역명 FROM DUAL
UNION ALL
SELECT '선릉' AS 역명 FROM DUAL
MINUS
SELECT '강남' AS 역명 FROM DUAL;

--중복된 '선릉'역을 출력하면서 '강남'역은 집합에서 제외
SELECT *
FROM (
  SELECT '선릉' AS 역명 FROM DUAL
  UNION ALL
  SELECT '선릉' AS 역명 FROM DUAL
) X --ALIAS
WHERE NOT EXISTS ( SELECT 1
                     FROM (
                            SELECT '강남' AS 역명 FROM DUAL
                          ) A --ALIAS
                    WHERE A.역명 = X.역명
                  )
;
SELECT '강남' AS 역명 FROM DUAL;
SELECT 1 AS 역명 FROM DUAL;
SELECT 1 FROM DUAL;

--계층형 SQL문
SELECT A.INDUTY_CL_CD
     , A.INDUTY_CL_NM
     , B.INDUTY_CL_SE_CD
     , B.INDUTY_CL_SE_NM
     , LEVEL LVL
     , LPAD(' ', 2*(LEVEL-1)) || A.INDUTY_CL_CD
                              || '('||A.INDUTY_CL_NM||')' AS "업종분류코드(명)"
     , CONNECT_BY_ISLEAF AS CBI
FROM TB_INDUTY_CL A
   , TB_INDUTY_CL_SE B
WHERE A.INDUTY_CL_SE_CD = B.INDUTY_CL_SE_CD
START WITH A.UPPER_INDUTY_CL_CD IS NULL
CONNECT BY PRIOR A.INDUTY_CL_CD = A.UPPER_INDUTY_CL_CD
ORDER SIBLINGS BY A.INDUTY_CL_CD
;

--계층형 SQL문 - START WITH 조건
SELECT B.INDUTY_CL_CD
     , B.INDUTY_CL_NM
     , LEVEL LVL
     , LPAD(' ', 2*(LEVEL-1)) || B.INDUTY_CL_CD
                              || '(' || B.INDUTY_CL_NM || ')' AS "업종분류코드(명)"
     , CONNECT_BY_ISLEAF AS CBI
     , INDUTY_CL_CD
FROM TB_INDUTY_CL B
START WITH B.INDUTY_CL_CD = 'Q12' --커피점/카페
CONNECT BY PRIOR B.INDUTY_CL_CD = B.UPPER_INDUTY_CL_CD
ORDER SIBLINGS BY B.INDUTY_CL_CD
;

--6-31 계층형 SQL문 - CONNECT_BY_ROOT 및 SYS_CONNECT_BY_PATH의 사용
SELECT B.INDUTY_CL_CD
     , B.INDUTY_CL_NM
     , LEVEL LVL
     , CONNECT_BY_ISLEAF AS CBI
     , CONNECT_BY_ROOT INDUTY_CL_CD AS "최상위업종분류코드"
     , SYS_CONNECT_BY_PATH(INDUTY_CL_CD
       || '(' || INDUTY_CL_NM || ')', '->')
       AS "업종분류코드경로"
FROM TB_INDUTY_CL B
START WITH B.INDUTY_CL_CD = 'Q12'
CONNECT BY PRIOR B.INDUTY_CL_CD = B.UPPER_INDUTY_CL_CD
ORDER SIBLINGS BY B.INDUTY_CL_CD
;

--6-32 계층형 SQL문 - SELF JOIN 활용
SELECT A.INDUTY_CL_CD
     , NVL(A.INDUTY_CL_NM, '(NULL)') AS INDUTY_CL_NM
     , NVL(A.UPPER_INDUTY_CL_CD, '(NULL)') AS "상위업종분류코드"
     , NVL(B.UPPER_INDUTY_CL_CD, '(NULL)') AS "차상위업종분류코드"
  FROM TB_INDUTY_CL A
     , TB_INDUTY_CL B
 WHERE A.UPPER_INDUTY_CL_CD = B.INDUTY_CL_CD
   AND A.INDUTY_CL_CD LIKE 'Q12%' --커피점/카페
   ORDER BY A.INDUTY_CL_CD
;